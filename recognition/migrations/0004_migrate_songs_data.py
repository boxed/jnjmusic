# Generated by Django 5.1.4 on 2025-06-22 12:46

from django.db import migrations
import json
from urllib.parse import unquote


def clean_spotify_id(spotify_id):
    """Clean up URL-encoded spotify IDs."""
    if not spotify_id:
        return spotify_id
    # Unquote URL-encoded strings
    decoded = unquote(spotify_id)
    # If it looks like it was incorrectly encoded (contains title/artist info), clear it
    if any(char in decoded for char in ['(', ')', '[', ']', 'feat.', 'ft.', ' by ']):
        return ''
    # If it's too long to be a real spotify ID, clear it
    if len(decoded) > 22:  # Spotify IDs are typically 22 characters
        return ''
    return decoded


def migrate_songs_forward(apps, schema_editor):
    """Migrate song data from RecognitionResult to Song model."""
    RecognitionResult = apps.get_model('recognition', 'RecognitionResult')
    Song = apps.get_model('recognition', 'Song')
    
    # Dictionary to track created songs
    songs_by_clean_spotify_id = {}
    songs_by_title_artists = {}
    
    # Process all recognition results
    total_results = RecognitionResult.objects.count()
    processed = 0
    
    for result in RecognitionResult.objects.all():
        song = None
        clean_sp_id = clean_spotify_id(result.spotify_id)
        
        # First, try to find existing song by cleaned spotify_id
        if clean_sp_id:
            if clean_sp_id in songs_by_clean_spotify_id:
                song = songs_by_clean_spotify_id[clean_sp_id]
            else:
                # Check if song with this spotify_id already exists
                existing_songs = Song.objects.filter(spotify_id=clean_sp_id)
                if existing_songs.exists():
                    song = existing_songs.first()
                    songs_by_clean_spotify_id[clean_sp_id] = song
        
        # If no song found by spotify_id, try by title and artists
        if not song:
            # Create a normalized key for title+artists
            artists_json = json.dumps(sorted(result.artists) if result.artists else [])
            key = f"{result.title.lower()}|{artists_json}"
            
            if key in songs_by_title_artists:
                song = songs_by_title_artists[key]
            else:
                # Check if song with this title+artists already exists
                # Note: We can't use the UniqueConstraint in the query, so we'll check manually
                for existing_song in Song.objects.filter(title=result.title):
                    if sorted(existing_song.artists or []) == sorted(result.artists or []):
                        song = existing_song
                        songs_by_title_artists[key] = song
                        # Update spotify_id if the existing song doesn't have one but this result does
                        if clean_sp_id and not existing_song.spotify_id:
                            existing_song.spotify_id = clean_sp_id
                            existing_song.save()
                            songs_by_clean_spotify_id[clean_sp_id] = existing_song
                        break
        
        # If still no song found, create a new one
        if not song:
            song_data = {
                'title': result.title,
                'artists': result.artists,
                'album': result.album,
                'duration_ms': result.duration_ms,
                'spotify_id': clean_sp_id,  # Use cleaned spotify_id
                'isrc': result.isrc,
                'external_ids': result.external_ids,
                'genres': result.genres,
                'release_date': result.release_date,
                'label': result.label,
            }
            
            song = Song.objects.create(**song_data)
            
            # Cache the created song
            if clean_sp_id:
                songs_by_clean_spotify_id[clean_sp_id] = song
            artists_json = json.dumps(sorted(result.artists) if result.artists else [])
            key = f"{result.title.lower()}|{artists_json}"
            songs_by_title_artists[key] = song
        
        # Update the recognition result to point to the song
        result.song = song
        result.save()
        
        processed += 1
        if processed % 100 == 0:
            print(f"Processed {processed}/{total_results} recognition results...")
    
    print(f"Migrated {RecognitionResult.objects.count()} recognition results")
    print(f"Created {Song.objects.count()} unique songs")


def migrate_songs_reverse(apps, schema_editor):
    """Reverse migration - clear song references."""
    RecognitionResult = apps.get_model('recognition', 'RecognitionResult')
    Song = apps.get_model('recognition', 'Song')
    
    # Clear all song references
    RecognitionResult.objects.update(song=None)
    
    # Delete all songs
    Song.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ("recognition", "0003_add_song_model"),
    ]

    operations = [
        migrations.RunPython(migrate_songs_forward, migrate_songs_reverse),
    ]